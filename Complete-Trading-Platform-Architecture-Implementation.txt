# üèóÔ∏è **Complete Trading Platform Architecture - From Scratch Implementation Guide**

This document explains every single component of the cryptocurrency trading platform implementation, from data collection to chart visualization.

## **üìä Data Flow Diagram:**
```
Binance WebSocket
       ‚Üì
   Price-Poller (splits data)
       ‚Üì                    ‚Üì
   Redis Stream         Redis Pub/Sub
       ‚Üì                    ‚Üì  
   Batch-Uploader       Realtime-Server
       ‚Üì                    ‚Üì
   TimescaleDB          Frontend WebSocket
       ‚Üì                    ‚Üì
Materialized Views    InstrumentPanel (live prices)
       ‚Üì
   HTTP Backend
       ‚Üì
Frontend TradingChart (candlesticks)
```

## 1Ô∏è‚É£ **PRICE-POLLER** - Data Collection Engine

**Location**: `apps/backend/price-poller/index.ts`

**Purpose**: Connects to Binance WebSocket API and splits data into two streams

### **Key Implementation Details:**

**WebSocket Connection:**
```typescript
const ws = new WebSocket("wss://stream.binance.com:9443/ws");
// Subscribes to: ["btcusdt@trade", "solusdt@trade", "ethusdt@trade"]

ws.onopen = () => {
  const subscribeMessage = {
    method: "SUBSCRIBE",
    params: SUPPORTED_PAIRS.map((p) => `${p}@trade`),
    id: 1,
  };
  ws.send(JSON.stringify(subscribeMessage));
};
```

**Data Processing:**
```typescript
ws.onmessage = async ({ data }) => {
  const payload = JSON.parse(data.toString());
  // Binance sends: {p: "108400.50", T: 1756480528000, s: "BTCUSDT"}
  // p = price, T = timestamp, s = symbol
  
  const originalPrice = parseFloat(payload.p);
  const SPREAD_PERCENTAGE = 0.001; // 0.1% house edge
  
  // Create spread for trading
  const manipulatedPrice = {
    bid: originalPrice * (1 - SPREAD_PERCENTAGE), // Lower for user sells
    ask: originalPrice * (1 + SPREAD_PERCENTAGE), // Higher for user buys
  };
```

**Two Data Streams:**

1. **HONEST prices ‚Üí Database (for charts):**
```typescript
let honestPriceData = {
  price: originalPrice,
  timestamp: payload.T,
  symbol: payload.s,
};

// Send to Redis Stream for database storage
await redisClient.xadd(
  BATCH_UPLOADER_STREAM,
  "*",
  "data",
  JSON.stringify(honestPriceData)
);
```

2. **MANIPULATED prices ‚Üí Live UI (with spread):**
```typescript
let manipulatedPriceData = {
  symbol: payload.s,
  originalPrice,
  bidPrice: manipulatedPrice.bid,
  askPrice: manipulatedPrice.ask,
  timestamp: payload.T,
};

// Publish to Redis channel for live trading UI
await redisClient.publish(
  `market:${payload.s}`,
  JSON.stringify(manipulatedPriceData)
);
```

## 2Ô∏è‚É£ **REDIS DATA FLOW** - Two Pathways

### **Path 1: Redis Streams (For Database)**
```typescript
// HONEST prices go to Redis Stream
await redisClient.xadd(
  "binance_trades_stream",  // Stream name
  "*",                      // Auto-generate ID
  "data", 
  JSON.stringify({
    price: 108400.50,
    timestamp: 1756480528000,
    symbol: "BTCUSDT"
  })
);
```

### **Path 2: Redis Pub/Sub (For Live UI)**
```typescript
// MANIPULATED prices go to Redis channel
await redisClient.publish(
  "market:BTCUSDT",         // Channel name
  JSON.stringify({
    symbol: "BTCUSDT",
    originalPrice: 108400.50,
    bidPrice: 108292.05,    // -0.1% for user sells
    askPrice: 108508.95,    // +0.1% for user buys  
    timestamp: 1756480528000
  })
);
```

## 3Ô∏è‚É£ **BATCH-UPLOADER** - Database Insertion Engine

**Location**: `apps/backend/batch-uploader/index.ts` & `processor.ts`

**Purpose**: Consumes Redis streams and batch-inserts honest price data to TimescaleDB

### **Redis Consumer Group Pattern:**
```typescript
// Initialize consumer group
await redisClient.xgroup("CREATE", "binance_trades_stream", "batch_uploader_group", "$", "MKSTREAM");

// Read messages in batches
const messages = await redisClient.xreadgroup(
  "GROUP", "batch_uploader_group", "batch_uploader_consumer",
  "COUNT", 100,           // Process 100 messages at once
  "BLOCK", 1000,          // Wait 1 second if no messages
  "STREAMS", "binance_trades_stream", ">"
);
```

### **Database Insertion Flow:**
```typescript
export async function processBatch(streamData: any[]) {
  const trades: PriceData[] = [];
  const messageIds: string[] = [];

  // 1. Parse each message from the stream
  for (const [messageId, fields] of streamData) {
    const dataIndex = fields.indexOf("data");
    if (dataIndex !== -1 && fields[dataIndex + 1]) {
      const tradeData = JSON.parse(fields[dataIndex + 1]);
      trades.push({
        price: tradeData.price,
        timestamp: tradeData.timestamp,
        symbol: tradeData.symbol,
      });
      messageIds.push(messageId);
    }
  }

  // 2. Batch insert to TimescaleDB
  if (trades.length > 0) {
    const insertData = trades.map(trade => ({
      time: new Date(trade.timestamp), // Convert Unix timestamp to Date
      symbol: trade.symbol,
      price: parseFloat(trade.price), // Convert string to number for Decimal
      // OHLC fields remain null initially, calculated by materialized views
      high: null,
      low: null,
      open: null,
      close: null
    }));

    await prisma.trade.createMany({
      data: insertData,
      skipDuplicates: true // Skip if duplicate composite key [id, time]
    });

    console.log(`‚úÖ Successfully inserted ${trades.length} trades to database`);
  }

  // 3. Acknowledge processed messages (removes from stream)
  if (messageIds.length > 0) {
    await redisClient.xack("binance_trades_stream", "batch_uploader_group", ...messageIds);
  }
}
```

## 4Ô∏è‚É£ **TIMESCALEDB MATERIALIZED VIEWS** - OHLCV Aggregation

**Purpose**: Aggregate raw trade data into candlestick (OHLCV) format for different timeframes

### **Database Schema:**
```sql
-- Raw trades table (hypertable)
model Trade {
  id        String    @default(cuid())
  time      DateTime  @db.Timestamptz  -- Partitioned by time
  symbol    String
  price     Decimal   @db.Decimal(20, 8)
  high      Decimal?  @db.Decimal(20, 8)  -- Unused for raw trades
  low       Decimal?  @db.Decimal(20, 8)  -- Unused for raw trades
  open      Decimal?  @db.Decimal(20, 8)  -- Unused for raw trades
  close     Decimal?  @db.Decimal(20, 8)  -- Unused for raw trades
  createdAt DateTime  @default(now())

  @@id([id, time])  -- Composite primary key for TimescaleDB
  @@map("trades")
}
```

### **Materialized Views Creation:**
```sql
-- 1-minute candles
CREATE MATERIALIZED VIEW trades_1m AS
SELECT
  time_bucket('1 minute', to_timestamp(time / 1000.0)) AS bucket,
  symbol,
  first(price, to_timestamp(time / 1000.0)) AS open,    -- First price in interval
  max(price) AS high,                                   -- Highest price
  min(price) AS low,                                    -- Lowest price  
  last(price, to_timestamp(time / 1000.0)) AS close,   -- Last price in interval
  count(*) AS volume                                    -- Trade count
FROM trades
GROUP BY bucket, symbol
ORDER BY bucket DESC;

-- 5-minute candles
CREATE MATERIALIZED VIEW trades_5m AS
SELECT
  time_bucket('5 minutes', to_timestamp(time / 1000.0)) AS bucket,
  symbol,
  first(price, to_timestamp(time / 1000.0)) AS open,
  max(price) AS high,
  min(price) AS low,
  last(price, to_timestamp(time / 1000.0)) AS close,
  count(*) AS volume
FROM trades
GROUP BY bucket, symbol
ORDER BY bucket DESC;

-- Similar views for: trades_15m, trades_1h, trades_4h, trades_1d
```

### **How Materialized Views Work:**
1. **time_bucket()** - TimescaleDB function groups timestamps into intervals
2. **first()/last()** - Gets chronologically first/last values
3. **min()/max()** - Calculates price extremes
4. **count(*)** - Counts trades as volume proxy
5. **GROUP BY bucket, symbol** - Creates candles per symbol per time interval

### **Refresh Strategy:**
```sql
-- Manual refresh (current approach)
REFRESH MATERIALIZED VIEW trades_1m;
REFRESH MATERIALIZED VIEW trades_5m;
-- ... etc for all views

-- Alternative: Continuous aggregates (automatic)
-- CREATE CONTINUOUS AGGREGATE trades_1m_continuous...
```

## 5Ô∏è‚É£ **REALTIME-SERVER** - Live Trading UI Data

**Location**: `apps/backend/realtime-server/index.ts`

**Purpose**: WebSocket server that broadcasts manipulated prices to frontend for live trading UI

### **Architecture:**
```typescript
// Three components working together:
1. WebSocket Server (port 3001) - Manages frontend connections  
2. Redis Subscriber - Listens to price-poller publications
3. Broadcast Logic - Sends data to all connected clients
```

### **Implementation:**
```typescript
// 1. WebSocket server setup
const wss = new WebSocketServer({ port: 3001 });
const clients = new Set<WebSocket>();

// 2. Redis subscriber setup
const subscriber = redisClient.duplicate();
await subscriber.connect();

// 3. Subscribe to Redis pattern
await subscriber.psubscribe('market:*');  // Listens to all market channels

// 4. Handle Redis messages
subscriber.on('pmessage', (pattern, channel, message) => {
  // channel = "market:BTCUSDT" 
  // message = {"symbol":"BTCUSDT","originalPrice":108400.50,"bidPrice":108292.05,"askPrice":108508.95,"timestamp":1756480528000}
  
  const symbol = channel.split(':')[1];  // Extract "BTCUSDT"
  broadcastToAllClients(symbol, message);
});

// 5. Broadcast to frontend WebSocket connections
function broadcastToAllClients(symbol, data) {
  const message = {
    type: 'price_update',
    symbol: 'BTCUSDT', 
    data: {
      symbol: 'BTCUSDT',
      originalPrice: 108400.50,
      bidPrice: 108292.05,    // For sell orders
      askPrice: 108508.95,    // For buy orders  
      timestamp: 1756480528000
    }
  };
  
  clients.forEach(ws => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  });
}

// 6. Handle WebSocket connections
wss.on('connection', (ws) => {
  clients.add(ws);
  
  // Send welcome message
  ws.send(JSON.stringify({
    type: 'connection',
    message: 'Connected to realtime crypto data',
    assets: ['BTCUSDT', 'ETHUSDT', 'SOLUSDT']
  }));
  
  ws.on('close', () => clients.delete(ws));
});
```

## 6Ô∏è‚É£ **HTTP BACKEND** - Chart Data API

**Location**: `apps/backend/http-backend/index.ts`

**Purpose**: REST API endpoint that serves historical candlestick data for charts

### **API Endpoint Implementation:**
```typescript
// GET /candles?asset=BTC&duration=5m&startTime=2025-08-29T14:00:00Z&endTime=2025-08-29T16:00:00Z

app.get("/candles", async (req, res) => {
  try {
    // 1. Parameter processing
    const { asset, duration, startTime, endTime } = req.query;
    const fullSymbol = asset === "BTC" ? "BTCUSDT" : `${asset}USDT`;  // Add USDT suffix if missing

    // 2. Select correct materialized view  
    const viewMap = {
      '30s': 'trades_30s',
      '1m': 'trades_1m',      // 1-minute candles
      '5m': 'trades_5m',      // 5-minute candles  
      '15m': 'trades_15m',
      '1h': 'trades_1h',      // 1-hour candles
      '4h': 'trades_4h',
      '1d': 'trades_1d'
    };
    const tableName = viewMap[duration];  // "trades_5m"

    // 3. Raw SQL query (can't use Prisma for dynamic table names)
    const query = `
      SELECT 
        bucket as time,     -- Time interval bucket
        open,              -- First price in interval
        high,              -- Highest price in interval  
        low,               -- Lowest price in interval
        close,             -- Last price in interval
        volume             -- Number of trades
      FROM ${tableName}    -- Dynamic table: trades_5m
      WHERE symbol = $1    -- "BTCUSDT"
      AND bucket >= $2     -- Start time filter
      AND bucket <= $3     -- End time filter  
      ORDER BY bucket ASC  -- Chronological order
      LIMIT 1000          -- Max 1000 candles
    `;

    // 4. Execute with Prisma
    const candles = await prisma.$queryRawUnsafe(
      query,
      fullSymbol,
      new Date(startTime as string),
      new Date(endTime as string)
    );

    // 5. Transform data for frontend
    const formattedCandles = candles.map(candle => ({
      time: Math.floor(candle.time.getTime() / 1000), // Date ‚Üí Unix seconds
      open: Number(candle.open),                       // Decimal ‚Üí number
      high: Number(candle.high),
      low: Number(candle.low), 
      close: Number(candle.close),
      volume: Number(candle.volume)
    }));

    // 6. Return response
    res.json({
      asset: fullSymbol,
      duration, 
      startTime: new Date(startTime as string).toISOString(),
      endTime: new Date(endTime as string).toISOString(),
      candles: formattedCandles
    });
  } catch (error) {
    console.error("Error fetching candles:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
```

### **CORS Configuration:**
```typescript
// Add CORS middleware for frontend access
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});
```

### **Response Format:**
```json
{
  "asset": "BTCUSDT",
  "duration": "5m", 
  "startTime": "2025-08-29T14:00:00.000Z",
  "endTime": "2025-08-29T16:00:00.000Z",
  "candles": [
    {
      "time": 1756477140,        // Unix timestamp in seconds
      "open": 108700.43,
      "high": 108723.46, 
      "low": 108666,
      "close": 108699.98,
      "volume": 2246
    }
    // ... more candles
  ]
}
```

## 7Ô∏è‚É£ **FRONTEND LIGHTWEIGHT-CHARTS** - Chart Implementation

**Location**: `apps/frontend/src/components/TradingChart.tsx`

**Purpose**: React component that renders professional candlestick charts using lightweight-charts library

### **Chart Initialization:**
```typescript
// 1. Create chart instance
const chart = createChart(chartContainerRef.current, {
  layout: { 
    background: { type: ColorType.Solid, color: '#1f2937' },
    textColor: '#d1d5db',
  },
  grid: { 
    vertLines: { color: '#374151' },
    horzLines: { color: '#374151' },
  },
  timeScale: { 
    timeVisible: true, 
    secondsVisible: false 
  }
});

// 2. Add candlestick series (v5.0.8 API)
const candlestickSeries = chart.addSeries(CandlestickSeries, {
  upColor: '#10b981',      // Green for bullish candles (close > open)
  downColor: '#ef4444',    // Red for bearish candles (close < open)
  borderUpColor: '#10b981',
  borderDownColor: '#ef4444',
  wickUpColor: '#10b981',
  wickDownColor: '#ef4444'
});

// 3. Add volume series as histogram
const volumeSeries = chart.addSeries(HistogramSeries, {
  color: '#6b7280',
  priceFormat: { type: 'volume' },
  priceScaleId: ''  // Separate price scale
});

// 4. Position volume at bottom
chart.priceScale('').applyOptions({
  scaleMargins: {
    top: 0.7,    // Volume takes bottom 30%
    bottom: 0,
  },
});
```

### **Data Fetching & Processing:**
```typescript
const fetchCandleData = async (asset: string, duration: TimeFrame) => {
  // 1. Build API request
  const endTime = new Date();
  const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000); // 24h ago
  
  const params = new URLSearchParams({
    asset: 'BTC',                           // -> "BTCUSDT" in backend
    duration: '5m',                         // -> trades_5m table
    startTime: '2025-08-29T14:00:00.000Z',
    endTime: '2025-08-29T16:00:00.000Z'
  });

  // 2. Fetch from HTTP backend
  const response = await fetch(`http://localhost:3002/candles?${params}`);
  const data = await response.json();
  
  // 3. Return candles array ready for lightweight-charts
  return data.candles; // Already formatted by backend
};
```

### **Data Loading & Chart Update:**
```typescript
const loadData = async () => {
  const candles = await fetchCandleData(symbol, timeFrame);
  
  if (candles.length > 0) {
    // 1. Set candlestick data directly (backend pre-formatted)
    candlestickSeriesRef.current.setData(candles);
    // candles = [
    //   {time: 1756477140, open: 108700.43, high: 108723.46, low: 108666, close: 108699.98, volume: 2246},
    //   {time: 1756477200, open: 108699.98, high: 108898.96, low: 108696.02, close: 108898.96, volume: 6915},
    //   // ...
    // ]
    
    // 2. Transform for volume histogram
    const volumeData = candles.map(candle => ({
      time: candle.time,                                              // Same timestamp
      value: candle.volume,                                          // Trade count
      color: candle.close >= candle.open ? '#10b98180' : '#ef444480' // Green/Red with transparency
    }));
    volumeSeriesRef.current.setData(volumeData);
    
    // 3. Auto-fit chart viewport
    chartRef.current.timeScale().fitContent();
    setHasData(true);
  } else {
    // Clear chart if no data
    candlestickSeriesRef.current.setData([]);
    volumeSeriesRef.current.setData([]);
    setHasData(false);
  }
};
```

### **React Lifecycle Management:**
```typescript
// Initialize chart on mount
useEffect(() => {
  if (!chartContainerRef.current || typeof window === 'undefined') return;
  
  // Create chart and series...
  
  // Handle window resize
  const handleResize = () => {
    if (chartContainerRef.current && chartRef.current) {
      chartRef.current.applyOptions({
        width: chartContainerRef.current.clientWidth,
        height: chartContainerRef.current.clientHeight,
      });
    }
  };
  window.addEventListener('resize', handleResize);
  
  // Cleanup on unmount
  return () => {
    window.removeEventListener('resize', handleResize);
    if (chartRef.current) {
      chartRef.current.remove();
      chartRef.current = null;
    }
  };
}, []);

// Load data when symbol/timeframe changes
useEffect(() => {
  if (typeof window === 'undefined') return;
  loadData();
}, [symbol, timeFrame]);
```

### **State Management:**
```typescript
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [hasData, setHasData] = useState(false);

// Error handling
if (error) {
  return (
    <div className="h-full flex items-center justify-center text-red-400">
      <div className="text-center">
        <div className="text-4xl mb-2">‚ö†Ô∏è</div>
        <div className="text-lg mb-2">Error loading chart</div>
        <div className="text-sm opacity-80">{error}</div>
        <button onClick={() => fetchCandleData(symbol, timeFrame)}>
          Retry
        </button>
      </div>
    </div>
  );
}

// No data state
if (!isLoading && !error && !hasData) {
  return (
    <div className="text-center text-yellow-400">
      <div className="text-4xl mb-2">üìä</div>
      <div className="text-lg mb-2">No Data Available</div>
      <div className="text-sm opacity-80">No {timeFrame} candle data found for {symbol}</div>
    </div>
  );
}
```

## **üîß Implementation Breakdown Summary:**

### **Key Technologies Used:**
- **WebSocket** - Real-time data streams (Binance API, Frontend communication)
- **Redis** - Pub/Sub + Streams for data routing and queuing
- **TimescaleDB** - Time-series database with materialized views for aggregation
- **Prisma** - Type-safe database ORM with raw SQL support
- **lightweight-charts** - Professional trading chart library (v5.0.8)
- **Next.js** - React framework with SSR and client-side rendering
- **Express.js** - HTTP server for REST API
- **TypeScript** - Type safety across all components

### **Architecture Patterns:**
1. **Event-driven architecture** - WebSocket events trigger data processing
2. **Publisher-Subscriber pattern** - Redis pub/sub for real-time data distribution  
3. **Consumer group pattern** - Redis streams for reliable data processing
4. **Materialized views** - Pre-aggregated data for fast queries
5. **Separation of concerns** - Different services for different responsibilities
6. **Type safety** - TypeScript interfaces across frontend and backend

### **Data Flow Summary:**
1. **Binance WebSocket** ‚Üí **price-poller** (splits honest/manipulated data)
2. **Redis Streams** ‚Üí **batch-uploader** ‚Üí **TimescaleDB** (honest data for charts)
3. **Redis Pub/Sub** ‚Üí **realtime-server** ‚Üí **Frontend WebSocket** (manipulated data for trading)
4. **TimescaleDB Materialized Views** ‚Üí **HTTP Backend** ‚Üí **TradingChart** (historical candles)
5. **Frontend** renders professional candlestick charts with volume indicators

This is a **production-ready cryptocurrency trading platform** with real-time data processing, time-series data storage, and professional chart visualization! üöÄüìà

## **üéØ Key Features Achieved:**
‚úÖ Real-time price collection from Binance
‚úÖ Dual data streams (honest for charts, manipulated for trading)
‚úÖ Reliable data processing with Redis consumer groups
‚úÖ Time-series data storage with TimescaleDB
‚úÖ OHLCV aggregation with materialized views
‚úÖ Live WebSocket price broadcasting
‚úÖ REST API for historical chart data
‚úÖ Professional candlestick charts with lightweight-charts
‚úÖ Volume histogram visualization
‚úÖ Interactive timeframe switching (1m, 5m, 15m, 1h, 4h, 1d)
‚úÖ Error handling and loading states
‚úÖ CORS support for frontend-backend communication
‚úÖ Type safety with TypeScript across the stack

This architecture can handle high-frequency trading data and scale horizontally as needed!